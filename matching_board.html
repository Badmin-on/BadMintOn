<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배드민턴 매칭 보드</title>
    <!-- Load React -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <!-- Load Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 0; background-color: #f9fafb; color: #374151; }
        .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
        .sticky-top { position: sticky; top: 0; z-index: 10; background-color: white; border-bottom: 1px solid #e5e7eb; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); padding: 1rem; }
        .main-content { padding: 1rem; }
        h1 { font-size: 1.5rem; font-weight: bold; margin-bottom: 0.5rem; text-align: center; color: #1d4ed8; }
        h2 { font-weight: 500; font-size: 0.875rem; margin-bottom: 0.25rem; }
        h3 { font-size: 1.125rem; font-weight: bold; }
        h4 { font-size: 0.875rem; font-weight: 500; margin-bottom: 0.25rem; }
        button { cursor: pointer; transition: background-color 0.2s; }
        button:disabled { cursor: not-allowed; opacity: 0.6; }
        input[type="text"] { padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; }
        .flex { display: flex; }
        .flex-1 { flex: 1 1 0%; }
        .flex-col { flex-direction: column; }
        .flex-wrap { flex-wrap: wrap; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .justify-center { justify-content: center; }
        .gap-1 { gap: 0.25rem; }
        .gap-2 { gap: 0.5rem; }
        .space-y-2 > :not([hidden]) ~ :not([hidden]) { margin-top: 0.5rem; }
        .space-y-4 > :not([hidden]) ~ :not([hidden]) { margin-top: 1rem; }
        .mb-1 { margin-bottom: 0.25rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mt-1 { margin-top: 0.25rem; }
        .mt-2 { margin-top: 0.5rem; }
        .ml-1 { margin-left: 0.25rem; }
        .ml-2 { margin-left: 0.5rem; }
        .mr-1 { margin-right: 0.25rem; }
        .mx-1 { margin-left: 0.25rem; margin-right: 0.25rem; }
        .p-1 { padding: 0.25rem; }
        .p-2 { padding: 0.5rem; }
        .p-3 { padding: 0.75rem; }
        .p-4 { padding: 1rem; }
        .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
        .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
        .py-3 { padding-top: 0.75rem; padding-bottom: 0.75rem; }
        .rounded { border-radius: 0.375rem; }
        .rounded-l { border-top-left-radius: 0.375rem; border-bottom-left-radius: 0.375rem; }
        .rounded-r { border-top-right-radius: 0.375rem; border-bottom-right-radius: 0.375rem; }
        .rounded-full { border-radius: 9999px; }
        .rounded-lg { border-radius: 0.5rem; }
        .border { border-width: 1px; }
        .border-2 { border-width: 2px; }
        .border-b { border-bottom-width: 1px; }
        .border-yellow-200 { border-color: #fef08a; }
        .border-yellow-300 { border-color: #fde047; }
        .border-green-600 { border-color: #16a34a; }
        .border-blue-600 { border-color: #2563eb; }
        .bg-gray-50 { background-color: #f9fafb; }
        .bg-gray-100 { background-color: #f3f4f6; }
        .bg-gray-200 { background-color: #e5e7eb; }
        .bg-yellow-50 { background-color: #fefce8; }
        .bg-yellow-100 { background-color: #fef9c3; }
        .bg-green-100 { background-color: #dcfce7; }
        .bg-green-600 { background-color: #16a34a; }
        .bg-green-300 { background-color: #86efac; }
        .bg-blue-50 { background-color: #eff6ff; }
        .bg-blue-100 { background-color: #dbeafe; }
        .bg-blue-300 { background-color: #93c5fd; }
        .bg-blue-500 { background-color: #3b82f6; }
        .bg-blue-600 { background-color: #2563eb; }
        .bg-red-50 { background-color: #fef2f2; }
        .bg-red-100 { background-color: #fee2e2; }
        .bg-purple-600 { background-color: #9333ea; }
        .text-white { color: white; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .text-center { text-align: center; }
        .text-gray-400 { color: #9ca3af; }
        .text-gray-500 { color: #6b7280; }
        .text-blue-600 { color: #2563eb; }
        .text-blue-700 { color: #1d4ed8; }
        .text-red-600 { color: #dc2626; }
        .text-red-700 { color: #b91c1c; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-medium { font-weight: 500; }
        .shadow-sm { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); }
        .shadow { box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1); }
        .underline { text-decoration: underline; }
        .overflow-auto { overflow: auto; }
        .grid { display: grid; }
        .grid-cols-1 { grid-template-columns: repeat(1, minmax(0, 1fr)); }
        .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); }
        @media (min-width: 768px) { .md\:grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)); } }

        /* Drag and Drop Styles */
        .player-button { cursor: grab; }
        .player-button:active { cursor: grabbing; }
        .drop-zone { border: 2px dashed transparent; transition: border-color 0.2s; min-height: 50px; /* Ensure drop zone has height */ }
        .drop-zone-over { border-color: #2563eb; background-color: #eff6ff; } /* Blue border when dragging over */
        .dragging { opacity: 0.5; border: 2px dashed #9ca3af; } /* Style for the item being dragged */

    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
      function BadmintonMatchingBoard() {
        const { useState, useRef } = React; // Add useRef

        const [players, setPlayers] = useState([]);
        const [newPlayerName, setNewPlayerName] = useState('');
        const [courts, setCourts] = useState([
          { id: 1, players: [], name: '1번 코트' },
          { id: 2, players: [], name: '2번 코트' },
          { id: 3, players: [], name: '3번 코트' },
          { id: 4, players: [], name: '4번 코트' },
          { id: 5, players: [], name: '5번 코트' },
        ]);
        // Removed selectedPlayer state, drag & drop handles selection implicitly
        // const [selectedPlayer, setSelectedPlayer] = useState(null);
        const [gameHistory, setGameHistory] = useState([]);
        const draggedPlayerId = useRef(null); // To store the ID of the player being dragged

        // --- Drag and Drop Handlers ---
        const handleDragStart = (e, playerId) => {
          draggedPlayerId.current = playerId;
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', playerId); // Necessary for Firefox
          e.currentTarget.classList.add('dragging'); // Add style to dragged item
          console.log(`Drag Start: Player ${playerId}`);
        };

        const handleDragOver = (e) => {
          e.preventDefault(); // Necessary to allow dropping
          e.dataTransfer.dropEffect = 'move';
          e.currentTarget.classList.add('drop-zone-over'); // Highlight drop zone
        };

        const handleDragEnter = (e) => {
          e.preventDefault();
          e.currentTarget.classList.add('drop-zone-over');
        };

        const handleDragLeave = (e) => {
          e.currentTarget.classList.remove('drop-zone-over');
        };

        const handleDropOnCourt = (e, courtId) => {
          e.preventDefault();
          e.currentTarget.classList.remove('drop-zone-over');
          const playerId = draggedPlayerId.current;
          if (!playerId) return;

          console.log(`Drop on Court ${courtId}: Player ${playerId}`);
          movePlayerToCourt(courtId, playerId); // Pass playerId directly
          draggedPlayerId.current = null; // Clear dragged player
        };

        const handleDropOnWaitingArea = (e) => {
           e.preventDefault();
           e.currentTarget.classList.remove('drop-zone-over');
           const playerId = draggedPlayerId.current;
           if (!playerId) return;

           console.log(`Drop on Waiting Area: Player ${playerId}`);
           movePlayerToWaitingArea(playerId); // Pass playerId directly
           draggedPlayerId.current = null; // Clear dragged player
        };

        const handleDragEnd = (e) => {
            // Clean up dragging styles regardless of drop success
            e.currentTarget.classList.remove('dragging');
            // Also remove hover styles from potential drop zones
            document.querySelectorAll('.drop-zone-over').forEach(el => el.classList.remove('drop-zone-over'));
            console.log("Drag End");
            // draggedPlayerId.current = null; // Already cleared on drop
        };


        // --- Player Management Functions (Modified for Drag & Drop) ---

        const addPlayer = () => {
          if (newPlayerName.trim() && players.length < 20) {
            const newPlayer = { id: Date.now(), name: newPlayerName.trim(), courtId: null };
            setPlayers([...players, newPlayer]);
            setNewPlayerName('');
          }
        };

        const removePlayer = (playerId) => {
          setPlayers(players.filter(player => player.id !== playerId));
          const updatedCourts = courts.map(court => ({
            ...court,
            players: court.players.filter(id => id !== playerId)
          }));
          setCourts(updatedCourts);
          // No need to handle selectedPlayer anymore
        };

        // Removed togglePlayerSelection as selection is handled by drag start

        const movePlayerToCourt = (courtId, playerIdToMove) => { // Accept playerIdToMove
          if (!playerIdToMove) return;

          const targetCourt = courts.find(court => court.id === courtId);
          const playerAlreadyInCourt = targetCourt.players.includes(playerIdToMove);

          if (targetCourt.players.length >= 4 && !playerAlreadyInCourt) {
            alert("코트에는 최대 4명까지만 배정할 수 있습니다.");
            return;
          }

          // Remove player from their current court (if any)
          const updatedCourts = courts.map(court => ({
            ...court,
            players: court.players.filter(id => id !== playerIdToMove)
          }));

          // Add player to the target court
          const finalCourts = updatedCourts.map(court => {
            if (court.id === courtId) {
              // Add only if not already present (handles dropping back onto same court)
              if (!court.players.includes(playerIdToMove)) {
                 return { ...court, players: [...court.players, playerIdToMove] };
              }
            }
            return court;
          });

          setCourts(finalCourts);

          // Update player's courtId
          const updatedPlayers = players.map(player =>
            player.id === playerIdToMove ? { ...player, courtId: courtId } : player
          );
          setPlayers(updatedPlayers);
        };

        const movePlayerToWaitingArea = (playerIdToMove) => { // Accept playerIdToMove
          if (!playerIdToMove) return;

          // Remove player from any court they might be on
          const updatedCourts = courts.map(court => ({
            ...court,
            players: court.players.filter(id => id !== playerIdToMove)
          }));
          setCourts(updatedCourts);

          // Update player's courtId to null
          const updatedPlayers = players.map(player =>
            player.id === playerIdToMove ? { ...player, courtId: null } : player
          );
          setPlayers(updatedPlayers);
        };

        // --- Game History and Reset Functions (Unchanged) ---
        const saveCurrentGame = () => {
          const currentGame = courts.map(court => {
            const courtPlayers = players.filter(player =>
              court.players.includes(player.id)
            ).sort((a, b) => {
              return court.players.indexOf(a.id) - court.players.indexOf(b.id);
            });
            const team1 = courtPlayers.filter((_, index) => index === 0 || index === 2);
            const team2 = courtPlayers.filter((_, index) => index === 1 || index === 3);
            return {
              courtId: court.id, courtName: court.name,
              team1: team1.map(p => p.name), team2: team2.map(p => p.name),
              playerOrder: courtPlayers.map(p => p.name)
            };
          }).filter(court => court.playerOrder.length > 0);

          if (currentGame.length > 0) {
            setGameHistory([...gameHistory, {
              id: Date.now(), timestamp: new Date().toLocaleString(), courts: currentGame
            }]);
             console.log("Game saved:", currentGame);
          } else {
             console.log("No active games to save.");
          }
        };

        const resetAllCourts = () => {
          const emptyCourts = courts.map(court => ({ ...court, players: [] }));
          setCourts(emptyCourts);
          const updatedPlayers = players.map(player => ({ ...player, courtId: null }));
          setPlayers(updatedPlayers);
          // No selectedPlayer to reset
        };

        const generateSamplePlayers = () => {
          const sampleNames = [
            '김민수', '이지연', '박준호', '최서연', '정민준', '강지훈', '윤소희', '장현우', '임지민', '한승우',
            '오민지', '신준영', '황지영', '조현우', '서민준', '권지원', '남현우', '류지민', '문승현', '홍지원'
          ];
          const samplePlayers = sampleNames.map((name, index) => ({
            id: Date.now() + index, name: name, courtId: null
          }));
          setPlayers(samplePlayers);
        };

        const waitingPlayers = players.filter(player => !player.courtId);

        return (
          <div className="container">
            {/* 고정된 상단 영역 */}
            <div className="sticky-top">
              <h1>배드민턴 매칭 프로그램</h1>
              {/* 선수 등록 영역 */}
              <div className="mb-4">
                <div className="flex">
                  <input type="text" value={newPlayerName} onChange={(e) => setNewPlayerName(e.target.value)}
                    placeholder="선수 이름을 입력하세요" className="flex-1 p-2 border rounded-l" maxLength={10}
                    onKeyPress={(e) => e.key === 'Enter' && addPlayer()} />
                  <button onClick={addPlayer} disabled={players.length >= 20 || !newPlayerName.trim()}
                    className="bg-blue-600 text-white px-4 py-2 rounded-r disabled:bg-blue-300">
                    추가
                  </button>
                </div>
                <div className="mt-2 flex justify-between">
                  <button onClick={generateSamplePlayers} disabled={players.length > 0}
                    className="bg-green-600 text-white px-3 py-1 rounded text-sm disabled:bg-green-300">
                    샘플 선수 생성
                  </button>
                  <div className="text-sm text-gray-500">선수: {players.length}/20</div>
                </div>
              </div>

              {/* 대기 선수 영역 (Drop Zone) */}
              <div
                className="bg-yellow-50 p-2 rounded border border-yellow-200 drop-zone"
                onDragOver={handleDragOver}
                onDragEnter={handleDragEnter}
                onDragLeave={handleDragLeave}
                onDrop={handleDropOnWaitingArea}
              >
                <div className="flex justify-between items-center mb-1">
                  <h2 className="font-medium text-sm">대기 선수 ({waitingPlayers.length})</h2>
                  {/* Removed selected player indicator */}
                </div>
                <div className="flex flex-wrap gap-1">
                  {waitingPlayers.map(player => (
                    <button
                      key={player.id}
                      draggable="true" // Make player draggable
                      onDragStart={(e) => handleDragStart(e, player.id)}
                      onDragEnd={handleDragEnd}
                      // Removed onClick selection toggle
                      className="player-button px-2 py-1 rounded-full text-sm flex items-center bg-yellow-100 border border-yellow-300"
                    >
                      <span>{player.name}</span>
                      <button
                        onClick={(e) => { e.stopPropagation(); removePlayer(player.id); }}
                        className="ml-1 text-red-600"
                        title={`[${player.name}] 제거`}
                      >
                        <span style={{ fontSize: '0.7em', verticalAlign: 'middle' }}>[X]</span>
                      </button>
                    </button>
                  ))}
                  {waitingPlayers.length === 0 && (
                    <span className="text-sm text-gray-500 p-1">대기 중인 선수가 없습니다</span>
                  )}
                </div>
              </div>
              {/* Removed selection guidance text */}
            </div>

            {/* 본문 영역 (스크롤 가능) */}
            <div className="main-content">
              {/* 코트 영역 */}
              <div className="mb-6 space-y-4">
                {courts.map(court => {
                  const courtPlayers = players.filter(player =>
                    court.players.includes(player.id)
                  ).sort((a, b) => court.players.indexOf(a.id) - court.players.indexOf(b.id));

                  const team1 = courtPlayers.filter((_, index) => index === 0 || index === 2);
                  const team2 = courtPlayers.filter((_, index) => index === 1 || index === 3);

                  return (
                    <div
                      key={court.id}
                      className="bg-green-100 p-3 rounded-lg border-2 border-green-600 drop-zone" // Make court a drop zone
                      onDragOver={handleDragOver}
                      onDragEnter={handleDragEnter}
                      onDragLeave={handleDragLeave}
                      onDrop={(e) => handleDropOnCourt(e, court.id)}
                    >
                      <div className="flex justify-between items-center mb-2">
                        <h3 className="text-lg font-bold">{court.name}</h3>
                        {/* Removed "Place Here" button */}
                        <span className="text-sm bg-white px-2 py-1 rounded-full">
                          {courtPlayers.length}/4
                        </span>
                      </div>

                      {courtPlayers.length > 0 ? (
                        <>
                          <div className="bg-white p-2 rounded mb-2">
                            <h4 className="text-sm font-medium mb-1">입장 순서</h4>
                            <div className="flex flex-wrap gap-1">
                              {courtPlayers.map((player, idx) => (
                                <div
                                  key={player.id}
                                  draggable="true" // Make players on court draggable too (to move to waiting)
                                  onDragStart={(e) => handleDragStart(e, player.id)}
                                  onDragEnd={handleDragEnd}
                                  className={`player-button px-2 py-1 rounded text-sm flex items-center
                                    ${(idx === 0 || idx === 2) ? 'bg-blue-100' : 'bg-red-100'}`}
                                >
                                  <span className="font-bold mr-1">{idx + 1}.</span>
                                  <span>{player.name}</span>
                                  <button
                                    onClick={() => removePlayer(player.id)} // Keep remove button
                                    className="ml-1 text-red-600"
                                    title={`[${player.name}] 제거`}
                                  >
                                     <span style={{ fontSize: '0.7em', verticalAlign: 'middle' }}>[X]</span>
                                  </button>
                                </div>
                              ))}
                            </div>
                          </div>

                          {courtPlayers.length >= 2 && (
                            <div className="bg-white p-2 rounded">
                              <h4 className="text-sm font-medium mb-1 flex items-center">
                                <span className="mr-1">[팀]</span>
                                <span>팀 구성 (1-3 vs 2-4)</span>
                              </h4>
                              <div className="grid grid-cols-2 gap-1">
                                  <div className="bg-blue-50 p-1 rounded">
                                      <p className="text-xs font-medium text-blue-700">팀 1</p>
                                      <p className="text-sm">{team1[0]?.name || '...'}</p>
                                      <p className="text-sm">{team1[1]?.name || '...'}</p>
                                  </div>
                                  <div className="bg-red-50 p-1 rounded">
                                      <p className="text-xs font-medium text-red-700">팀 2</p>
                                      <p className="text-sm">{team2[0]?.name || '...'}</p>
                                      <p className="text-sm">{team2[1]?.name || '...'}</p>
                                  </div>
                              </div>
                            </div>
                          )}
                        </>
                      ) : (
                        <div className="bg-white p-4 rounded text-center text-gray-500 min-h-[50px] flex items-center justify-center">
                          <p>비어있는 코트</p>
                          {/* Simplified message */}
                        </div>
                      )}

                      {courtPlayers.length > 0 && (
                        <div className="mt-2 flex justify-end">
                          <button
                            onClick={() => { /* Logic remains the same */
                              const playerIdsToMove = [...court.players];
                              const updatedCourts = courts.map(c => c.id === court.id ? { ...c, players: [] } : c);
                              setCourts(updatedCourts);
                              const updatedPlayers = players.map(p => playerIdsToMove.includes(p.id) ? { ...p, courtId: null } : p);
                              setPlayers(updatedPlayers);
                            }}
                            className="bg-red-100 text-red-600 px-2 py-1 rounded flex items-center text-sm"
                          >
                            <span className="mr-1">[초기화]</span>
                            코트 비우기
                          </button>
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>

              {/* 게임 관리 영역 */}
              <div className="mb-6 flex justify-center">
                <button
                  onClick={() => { saveCurrentGame(); resetAllCourts(); }}
                  className="bg-purple-600 text-white px-6 py-3 rounded-lg font-semibold"
                  disabled={players.every(p => !p.courtId)}
                >
                  게임 종료 및 새 게임 준비
                </button>
              </div>

              {/* 게임 히스토리 */}
              {gameHistory.length > 0 && (
                <div className="p-4 bg-white rounded-lg shadow">
                  <h2 className="text-xl font-semibold mb-4">게임 기록</h2>
                  <div className="space-y-4">
                    {gameHistory.slice().reverse().map((game, index) => (
                      <div key={game.id} className="border p-3 rounded">
                        <h3 className="font-medium">게임 #{gameHistory.length - index}: {game.timestamp}</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2 mt-2">
                          {game.courts.map(court => (
                            <div key={court.courtId} className="border p-2 rounded bg-gray-50">
                              <p className="font-medium">{court.courtName}</p>
                              <div className="mt-1 mb-2">
                                <p className="text-xs font-medium">입장 순서:</p>
                                <div className="flex flex-wrap gap-1 mt-1">
                                  {court.playerOrder.map((name, idx) => (
                                    <span key={idx} className="text-xs bg-gray-100 px-1 rounded">{idx+1}. {name}</span>
                                  ))}
                                </div>
                              </div>
                              <div className="grid grid-cols-2 gap-1">
                                <div className="bg-blue-50 p-1 rounded">
                                  <p className="text-xs font-medium text-blue-700">팀 1:</p>
                                  {court.team1.map((name, i) => (<p key={i} className="text-sm">{name || 'N/A'}</p>))}
                                  {court.team1.length < 2 && <p className="text-sm text-gray-400">...</p>}
                                </div>
                                <div className="bg-red-50 p-1 rounded">
                                  <p className="text-xs font-medium text-red-700">팀 2:</p>
                                  {court.team2.map((name, i) => (<p key={i} className="text-sm">{name || 'N/A'}</p>))}
                                   {court.team2.length < 2 && <p className="text-sm text-gray-400">...</p>}
                                </div>
                              </div>
                            </div>
                          ))}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        );
      }

      ReactDOM.render(<BadmintonMatchingBoard />, document.getElementById('root'));

    </script>
</body>
</html>
